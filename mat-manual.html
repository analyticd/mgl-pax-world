<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>MAT Manual</title>
<link type='text/css' href='style.css' rel='stylesheet'/>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body><p><a name='x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29'></a></p>

<h1><span class="navigation"> <a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8634;</a></span>MAT Manual</h1>

<h2>Table of Contents</h2>

<ul>
<li><a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">1 mgl-mat ASDF System Details</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INTRODUCTION MGL-PAX:SECTION)">2 Introduction</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-IS-IT MGL-PAX:SECTION)">2.1 What's MGL-MAT?</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-KIND-OF-MATRICES MGL-PAX:SECTION)">2.2 What kind of matrices are supported?</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INSTALLATION MGL-PAX:SECTION)">2.3 Installation</a></li>
</ul></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BASICS MGL-PAX:SECTION)">3 Basics</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CTYPES MGL-PAX:SECTION)">4 Element types</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-PRINTING MGL-PAX:SECTION)">5 Printing</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-SHAPING MGL-PAX:SECTION)">6 Shaping</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-ASSEMBLING MGL-PAX:SECTION)">7 Assembling</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CACHING MGL-PAX:SECTION)">8 Caching</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-FOREIGN MGL-PAX:SECTION)">9 Foreign arrays</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUDA MGL-PAX:SECTION)">10 CUDA</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUBLAS MGL-PAX:SECTION)">10.1 CUBLAS</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CURAND MGL-PAX:SECTION)">10.2 CURAND</a></li>
</ul></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BLAS MGL-PAX:SECTION)">11 BLAS</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-DESTRUCTIVE-API MGL-PAX:SECTION)">12 Destructive API</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-NON-DESTRUCTIVE-API MGL-PAX:SECTION)">13 Non-destructive API</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MAPPINGS MGL-PAX:SECTION)">14 Mappings</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-RANDOM MGL-PAX:SECTION)">15 Random numbers</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-IO MGL-PAX:SECTION)">16 I/O</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-EXTENSION-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-EXTENSION-API MGL-PAX:SECTION)">17 Extension API</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-DEBUGGING MGL-PAX:SECTION)">18 Debugging</a></li>
</ul>

<h6>[in package MGL-MAT]</h6>

<p><a name='x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INTRODUCTION MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">&#8634;</a></span>1 mgl-mat ASDF System Details</h2>

<ul>
<li>Version: 0.0.1</li>
<li>Description: MAT is library for working with multi-dimensional
  arrays which supports efficient interfacing to foreign and CUDA
  code. BLAS and CUBLAS bindings are available.</li>
<li>Licence: MIT, see COPYING.</li>
<li>Author: GÃ¡bor Melis</li>
<li>Mailto: <a href="mailto:mega@retes.hu" >mega@retes.hu</a></li>
<li>Homepage: <a href="http://quotenil.com" >http://quotenil.com</a></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-IS-IT MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INTRODUCTION MGL-PAX:SECTION)">&#8634;</a></span>2 Introduction</h2>

<p><a name='x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29'></a></p>

<h3><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INTRODUCTION MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INTRODUCTION MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-KIND-OF-MATRICES MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-IS-IT MGL-PAX:SECTION)">&#8634;</a></span>2.1 What's MGL-MAT?</h3>

<p>MGL-MAT is library for working with multi-dimensional arrays
which supports efficient interfacing to foreign and CUDA code with
automatic translations between cuda, foreign and lisp storage. BLAS
and CUBLAS bindings are available.</p>

<p><a name='x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29'></a></p>

<h3><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-IS-IT MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INTRODUCTION MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INSTALLATION MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-KIND-OF-MATRICES MGL-PAX:SECTION)">&#8634;</a></span>2.2 What kind of matrices are supported?</h3>

<p>Currently only row-major single and double float matrices are
supported, but it would be easy to add single and double precision
complex types too. Other numeric types, such as byte and native
integer, can be added too, but they are not supported by CUBLAS.
There are no restrictions on the number of dimensions, and reshaping
is possible. The CUBLAS functions operate on the visible portion of
the matrix (which is subject to displacement and shaping), invisible
elements are not affected.</p>

<p><a name='x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29'></a></p>

<h3><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-WHAT-KIND-OF-MATRICES MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INTRODUCTION MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BASICS MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INSTALLATION MGL-PAX:SECTION)">&#8634;</a></span>2.3 Installation</h3>

<p>All dependencies are in quicklisp except for cl-cuda and some of
its dependencies: cl-pattern and cl-reexport which you need to get
from github.</p>

<p><a name='x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-INSTALLATION MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CTYPES MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BASICS MGL-PAX:SECTION)">&#8634;</a></span>3 Basics</h2>

<p>A <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> is a <a href="cube-manual.html#x-28MGL-CUBE-3ACUBE-20CLASS-29" title="(MGL-CUBE:CUBE CLASS)"><code>CUBE</code></a> (see <a href="cube-manual.html#x-28MGL-CUBE-3A-40CUBE-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-CUBE:@CUBE-MANUAL MGL-PAX:SECTION)">Cube Manual</a>) whose facets are different
representations of numeric arrays. These facets can be accessed with
<a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a> with one of the following <a href="cube-manual.html#x-28MGL-CUBE-3AFACET-NAME-20MGL-PAX-3ALOCATIVE-29" title="(MGL-CUBE:FACET-NAME MGL-PAX:LOCATIVE)"><code>FACET-NAME</code></a>s:</p>

<p><a name='x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p>[facet-name] <strong>BACKING-ARRAY</strong></p>

<p>The corresponding facet is a one dimensional lisp array.</p></li>
</ul>

<p><a name='x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p>[facet-name] <strong>ARRAY</strong></p>

<p>Same as <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> if the matrix is one-dimensional, all
elements are visible (see <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-SHAPING MGL-PAX:SECTION)">Shaping</a>), else it's a lisp array
displaced to the backing array.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p>[facet-name] <strong>FOREIGN-ARRAY</strong></p>

<p>The facet is a <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>FOREIGN-ARRAY</code></a> which is an <code>OFFSET-POINTER</code>
wrapping a CFFI:POINTER. See <a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" title="(MGL-MAT:*FOREIGN-ARRAY-STRATEGY* (VARIABLE \&quot;-see below-\&quot;))"><code>*FOREIGN-ARRAY-STRATEGY*</code></a>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p>[facet-name] <strong>CUDA-ARRAY</strong></p>

<p>The facet is <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> which is an <code>OFFSET-POINTER</code> wrapping a
<code>CL-CUDA.DRIVER-API:CU-DEVICE-PTR</code>, allocated with CU-MEM-ALLOC and
freed automatically.</p>

<p>Facets bound by with <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a> are to be treated as dynamic
extent: it is not allowed to keep a reference to them beyond the
dynamic scope of <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a>.</p>

<p>For example, to fill matrix X of <a href="#x-28MGL-MAT-3ACTYPE-20TYPE-29" title="(MGL-MAT:CTYPE TYPE)"><code>CTYPE</code></a> <code>:DOUBLE</code> with ones it most
convenient to work with the one dimensional <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a>:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">displacement <span class="paren4">(<span class="code">mat-displacement x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">size <span class="paren4">(<span class="code">mat-size x</span>)</span></span>)</span></span>)</span>
 <span class="paren2">(<span class="code"><i><span class="symbol">with-facets</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">x* <span class="paren5">(<span class="code">x 'backing-array <span class="keyword">:direction</span> <span class="keyword">:output</span></span>)</span></span>)</span></span>)</span>
   <span class="paren3">(<span class="code">fill x* 1d0 <span class="keyword">:start</span> displacement <span class="keyword">:end</span> <span class="paren4">(<span class="code">+ displacement size</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p><a href="cube-manual.html#x-28MGL-CUBE-3ADIRECTION-20TYPE-29" title="(MGL-CUBE:DIRECTION TYPE)"><code>DIRECTION</code></a> is <code>:OUTPUT</code> because we clobber all values in X. Armed with
this knowledge about the direction, <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a> will not copy data
from another facet if the backing array is not up-to-date.</p>

<p>To transpose a 2d matrix with the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">destructuring-bind <span class="paren2">(<span class="code">n-rows n-columns</span>)</span> <span class="paren2">(<span class="code">mat-dimensions x</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">with-facets</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">x* <span class="paren5">(<span class="code">x 'array <span class="keyword">:direction</span> <span class="keyword">:io</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">dotimes <span class="paren4">(<span class="code">row n-rows</span>)</span>
      <span class="paren4">(<span class="code">dotimes <span class="paren5">(<span class="code">column n-columns</span>)</span>
        <span class="paren5">(<span class="code">setf <span class="paren6">(<span class="code">aref x* row column</span>)</span> <span class="paren6">(<span class="code">aref x* column row</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Note that <a href="cube-manual.html#x-28MGL-CUBE-3ADIRECTION-20TYPE-29" title="(MGL-CUBE:DIRECTION TYPE)"><code>DIRECTION</code></a> is <code>:IO</code>, because we need the data in this facet
to be up-to-date (that's the input part) and we are invalidating all
other facets by changing values (that's the output part).</p>

<p>To sum the values of a matrix using the <code>FOREIGN-ARRAY</code>(<a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>0</code></a> <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>1</code></a>) facet:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">sum 0</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">with-facets</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">x* <span class="paren5">(<span class="code">x 'foreign-array <span class="keyword">:direction</span> <span class="keyword">:input</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">pointer <span class="paren6">(<span class="code">offset-pointer x*</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">loop</span></i> for index below <span class="paren5">(<span class="code">mat-size x</span>)</span>
            do <span class="paren5">(<span class="code">incf sum <span class="paren6">(<span class="code">cffi:mem-aref pointer <span class="paren1">(<span class="code">mat-ctype x</span>)</span> index</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
  sum</span>)</span></span></code></pre>

<p>See <a href="cube-manual.html#x-28MGL-CUBE-3ADIRECTION-20TYPE-29" title="(MGL-CUBE:DIRECTION TYPE)"><code>DIRECTION</code></a> for a complete description of <code>:INPUT</code>, <code>:OUTPUT</code> and <code>:IO</code>.
For <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects, that needs to be refined. If a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> is reshaped
and/or displaced in a way that not all elements are visible then
those elements are always kept intact and copied around. This is
accomplished by turning <code>:OUTPUT</code> into <code>:IO</code> automatically on such MATs.</p>

<p>Most operations automatically use CUDA, if available and
initialized. See <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a> for detail.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-20CLASS-29'></a></p>

<ul>
<li><p>[class] <strong>MAT</strong> <em>CUBE</em></p>

<p>A <code>MAT</code> is a data <a href="cube-manual.html#x-28MGL-CUBE-3ACUBE-20CLASS-29" title="(MGL-CUBE:CUBE CLASS)"><code>CUBE</code></a> that is much like a lisp
array, it supports <code>DISPLACEMENT</code>, arbitrary <code>DIMENSIONS</code> and
<code>INITIAL-ELEMENT</code> with the usual semantics. However, a <code>MAT</code> supports
different representations of the same data. See <a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BASICS MGL-PAX:SECTION)">Basics</a> for a
tuturialish treatment.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-CTYPE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p>[reader] <strong>MAT-CTYPE</strong> <em>MAT</em> <em>(:CTYPE = *DEFAULT-MAT-CTYPE*)</em></p>

<p>One of <a href="#x-28MGL-MAT-3A-2ASUPPORTED-CTYPES-2A-20VARIABLE-29" title="(MGL-MAT:*SUPPORTED-CTYPES* VARIABLE)"><code>*SUPPORTED-CTYPES*</code></a>. The matrix can hold
only values of this type.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-DISPLACEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p>[reader] <strong>MAT-DISPLACEMENT</strong> <em>MAT</em> <em>(:DISPLACEMENT = 0)</em></p>

<p>A value in the [0,MAX-SIZE][] interval. This is like
the DISPLACED-INDEX-OFFSET of a lisp array.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-DIMENSIONS-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p>[reader] <strong>MAT-DIMENSIONS</strong> <em>MAT</em> <em>(:DIMENSIONS)</em></p>

<p>Like <code>ARRAY-DIMENSIONS</code>. It holds a list of
dimensions, but it is allowed to pass in scalars too.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-DIMENSION-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MAT-DIMENSION</strong> <em>MAT AXIS-NUMBER</em></p>

<p>Return the dimension along <code>AXIS-NUMBER</code>. Similar to
<code>ARRAY-DIMENSION</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-INITIAL-ELEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p>[reader] <strong>MAT-INITIAL-ELEMENT</strong> <em>MAT</em> <em>(:INITIAL-ELEMENT = 0)</em></p>

<p>If non-nil, then when a facet is created, it is
filled with <code>INITIAL-ELEMENT</code> coerced to the appropriate numeric
type. If <code>NIL</code>, then no initialization is performed.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p>[reader] <strong>MAT-SIZE</strong> <em>MAT</em></p>

<p>The number of elements in the visible portion of
the array. This is always the product of the elements
<a href="#x-28MGL-MAT-3AMAT-DIMENSIONS-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-DIMENSIONS (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-DIMENSIONS</code></a> and is similar to <code>ARRAY-TOTAL-SIZE</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-MAX-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p>[reader] <strong>MAT-MAX-SIZE</strong> <em>MAT</em> <em>(:MAX-SIZE)</em></p>

<p>The total size can be larger than <a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a>, but
cannot change. Also <code>DISPLACEMENT</code> + <code>SIZE</code> must not exceed it. This
is not</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAKE-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MAKE-MAT</strong> <em>DIMENSIONS &amp;REST ARGS &amp;KEY (CTYPE *DEFAULT-MAT-CTYPE*) (DISPLACEMENT 0) MAX-SIZE (INITIAL-ELEMENT 0) INITIAL-CONTENTS (SYNCHRONIZATION *DEFAULT-SYNCHRONIZATION*)</em></p>

<p>Return a new matrix. If <code>INITIAL-CONTENTS</code> is given then the matrix
contents are copied with <a href="#x-28MGL-MAT-3AREPLACE-21-20FUNCTION-29" title="(MGL-MAT:REPLACE! FUNCTION)"><code>REPLACE!</code></a>. See class <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> for the description
of the rest of the parameters. This is exactly what (<code>MAKE-INSTANCE</code>
'<a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> ...) does except <code>DIMENSIONS</code> is not a keyword argument so
<a href="#x-28MGL-MAT-3AMAKE-MAT-20FUNCTION-29" title="(MGL-MAT:MAKE-MAT FUNCTION)"><code>MAKE-MAT</code></a> looks more like <code>MAKE-ARRAY</code>. Also see
<a href="cube-manual.html#x-28MGL-CUBE-3A-40CUBE-SYNCHRONIZATION-20MGL-PAX-3ASECTION-29" title="(MGL-CUBE:@CUBE-SYNCHRONIZATION MGL-PAX:SECTION)">Synchronization</a>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AARRAY-TO-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>ARRAY-TO-MAT</strong> <em>ARRAY &amp;KEY CTYPE (SYNCHRONIZATION *DEFAULT-SYNCHRONIZATION*)</em></p>

<p>Create a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> that's equivalent to <code>ARRAY</code>. Displacement of the
created array will be 0 and the size will be equal to
<code>ARRAY-TOTAL-SIZE</code>. If <code>CTYPE</code> is non-nil, then it will be the ctype of
the new matrix. Else <code>ARRAY</code>'s type is converted to a ctype. If there
is no corresponding ctype, then <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a> is used.
Elements of <code>ARRAY</code> are coerced to <code>CTYPE</code>.</p>

<p>Also see <a href="cube-manual.html#x-28MGL-CUBE-3A-40CUBE-SYNCHRONIZATION-20MGL-PAX-3ASECTION-29" title="(MGL-CUBE:@CUBE-SYNCHRONIZATION MGL-PAX:SECTION)">Synchronization</a>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-TO-ARRAY-20FUNCTION-29'></a></p>

<ul>
<li>[function] <strong>MAT-TO-ARRAY</strong> <em>MAT</em></li>
</ul>

<p><a name='x-28MGL-MAT-3AREPLACE-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>REPLACE!</strong> <em>MAT SEQ-OF-SEQS</em></p>

<p>Replace the contents of <code>MAT</code> with the elements of <code>SEQ-OF-SEQS</code>.
<code>SEQ-OF-SEQS</code> is a nested sequence of sequences similar to the
<code>INITIAL-CONTENTS</code> argument of <code>MAKE-ARRAY</code>. The total number of
elements must match the size of <code>MAT</code>. Returns <code>MAT</code>.</p>

<p><code>SEQ-OF-SEQS</code> may contain multi-dimensional arrays as <em>leafs</em>, so the
following is legal:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">replace! <span class="paren2">(<span class="code">make-mat '<span class="paren3">(<span class="code">1 2 3</span>)</span></span>)</span> '<span class="paren2">(<span class="code">#2A<span class="paren3">(<span class="code"><span class="paren4">(<span class="code">1 2 3</span>)</span> <span class="paren4">(<span class="code">4 5 6</span>)</span></span>)</span></span>)</span></span>)</span>
==&gt; #&lt;MAT 1x2x3 AB #3A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1.0d0 2.0d0 3.0d0</span>)</span> <span class="paren3">(<span class="code">4.0d0 5.0d0 6.0d0</span>)</span></span>)</span></span>)</span>&gt;</span></code></pre></li>
</ul>

<p><a name='x-28MGL-MAT-3AMREF-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MREF</strong> <em>MAT &amp;REST INDICES</em></p>

<p>Like <code>AREF</code> for arrays. Don't use this if you care about performance
at all. SETFable. When set, the value is coerced to the ctype of <code>MAT</code>
with <a href="#x-28MGL-MAT-3ACOERCE-TO-CTYPE-20FUNCTION-29" title="(MGL-MAT:COERCE-TO-CTYPE FUNCTION)"><code>COERCE-TO-CTYPE</code></a>. Note that currently <a href="#x-28MGL-MAT-3AMREF-20FUNCTION-29" title="(MGL-MAT:MREF FUNCTION)"><code>MREF</code></a> always operates on
the <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> facet so it can trigger copying of facets. When
it's <code>SETF</code>'ed, however, it will update the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> if cuda is
enabled and it is up-to-date or there are no views at all.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AROW-MAJOR-MREF-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>ROW-MAJOR-MREF</strong> <em>MAT INDEX</em></p>

<p>Like <code>ROW-MAJOR-AREF</code> for arrays. Don't use this if you care about
performance at all. SETFable. When set, the value is coerced to the
ctype of <code>MAT</code> with <a href="#x-28MGL-MAT-3ACOERCE-TO-CTYPE-20FUNCTION-29" title="(MGL-MAT:COERCE-TO-CTYPE FUNCTION)"><code>COERCE-TO-CTYPE</code></a>. Note that currently
<a href="#x-28MGL-MAT-3AROW-MAJOR-MREF-20FUNCTION-29" title="(MGL-MAT:ROW-MAJOR-MREF FUNCTION)"><code>ROW-MAJOR-MREF</code></a> always operates on the <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> facet so it can
trigger copying of facets. When it's <code>SETF</code>'ed, however, it will
update the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> if cuda is enabled and it is up-to-date or
there are no views at all.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BASICS MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-PRINTING MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CTYPES MGL-PAX:SECTION)">&#8634;</a></span>4 Element types</h2>

<p><a name='x-28MGL-MAT-3A-2ASUPPORTED-CTYPES-2A-20VARIABLE-29'></a></p>

<ul>
<li>[variable] <strong>*SUPPORTED-CTYPES*</strong> <em>(:FLOAT :DOUBLE)</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ACTYPE-20TYPE-29'></a></p>

<ul>
<li>[type] <strong>CTYPE</strong></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*DEFAULT-MAT-CTYPE*</strong> <em>:DOUBLE</em></p>

<p>By default MATs are created with this ctype. One of <code>:FLOAT</code>
or <code>:DOUBLE</code> (the default).</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACOERCE-TO-CTYPE-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>COERCE-TO-CTYPE</strong> <em>X &amp;KEY (CTYPE *DEFAULT-MAT-CTYPE*)</em></p>

<p>Coerce the scalar <code>X</code> to the lisp type corresponding to <code>CTYPE</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CTYPES MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-SHAPING MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-PRINTING MGL-PAX:SECTION)">&#8634;</a></span>5 Printing</h2>

<p><a name='x-28MGL-MAT-3A-2APRINT-MAT-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*PRINT-MAT*</strong> <em>T</em></p>

<p>Controls whether the contents of a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> object are printed as an
array (subject to the standard printer control variables).</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2APRINT-MAT-FACETS-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*PRINT-MAT-FACETS*</strong> <em>T</em></p>

<p>Controls whether a summary of existing and up-to-date views is
printed whe a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> object is printed. The summary that looks like
<code>ABcf</code> indicates that all four facets (<a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a>, <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a>,
<a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a>, <code>FOREIGN-ARRAY</code>(<a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>0</code></a> <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>1</code></a>)) are present and the first two are
up-to-date. A summary of a single #- indicates that there are no
facets.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-PRINTING MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-ASSEMBLING MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-SHAPING MGL-PAX:SECTION)">&#8634;</a></span>6 Shaping</h2>

<p>Reshaping and displacement of <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects works somewhat similarly
to lisp arrays. The key difference is that they are destructive
operations. See <a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-AND-DISPLACE! FUNCTION)"><code>RESHAPE-AND-DISPLACE!</code></a>, <a href="#x-28MGL-MAT-3ARESHAPE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE! FUNCTION)"><code>RESHAPE!</code></a>, <a href="#x-28MGL-MAT-3ADISPLACE-21-20FUNCTION-29" title="(MGL-MAT:DISPLACE! FUNCTION)"><code>DISPLACE!</code></a>,
<a href="#x-28MGL-MAT-3ARESHAPE-TO-ROW-MATRIX-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-TO-ROW-MATRIX! FUNCTION)"><code>RESHAPE-TO-ROW-MATRIX!</code></a> and <a href="#x-28MGL-MAT-3AWITH-SHAPE-AND-DISPLACEMENT-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-SHAPE-AND-DISPLACEMENT MGL-PAX:MACRO)"><code>WITH-SHAPE-AND-DISPLACEMENT</code></a>. <a href="#x-28MGL-MAT-3AADJUST-21-20FUNCTION-29" title="(MGL-MAT:ADJUST! FUNCTION)"><code>ADJUST!</code></a> is
the odd one out, it may create a new <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a>.</p>

<p>Existing facets are adjusted by all operations. For LISP-ARRAY
facets, this means creating a new lisp array displaced to the
backing array. The backing array stays the same, clients are
supposed to observe <a href="#x-28MGL-MAT-3AMAT-DISPLACEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-DISPLACEMENT (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-DISPLACEMENT</code></a>, <a href="#x-28MGL-MAT-3AMAT-DIMENSIONS-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-DIMENSIONS (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-DIMENSIONS</code></a> or <a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a>.
The <code>FOREIGN-ARRAY</code>(<a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>0</code></a> <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>1</code></a>) and <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facets are <code>OFFSET-POINTER</code>'s so
displacement is done by changing the offset. Clients need to observe
<a href="#x-28MGL-MAT-3AMAT-DIMENSIONS-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-DIMENSIONS (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-DIMENSIONS</code></a> in any case.</p>

<p><a name='x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>RESHAPE-AND-DISPLACE!</strong> <em>MAT DIMENSIONS DISPLACEMENT</em></p>

<p>Change the visible (or active) portion of <code>MAT</code> by altering its
displacement offset and dimensions. Future operations will only
affect this visible portion as if the rest of the elements were not
there. Return <code>MAT</code>.</p>

<p><code>DISPLACEMENT</code> + the new size must not exceed <a href="#x-28MGL-MAT-3AMAT-MAX-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-MAX-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-MAX-SIZE</code></a>.
Furthermore, there must be no facets being viewed (with <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a>)
when calling this function as the identity of the facets is not
stable.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ARESHAPE-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>RESHAPE!</strong> <em>MAT DIMENSIONS</em></p>

<p>Like <a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-AND-DISPLACE! FUNCTION)"><code>RESHAPE-AND-DISPLACE!</code></a> but only alters the dimensions.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ADISPLACE-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>DISPLACE!</strong> <em>MAT DISPLACEMENT</em></p>

<p>Like <a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-AND-DISPLACE! FUNCTION)"><code>RESHAPE-AND-DISPLACE!</code></a> but only alters the displacement.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ARESHAPE-TO-ROW-MATRIX-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>RESHAPE-TO-ROW-MATRIX!</strong> <em>MAT ROW</em></p>

<p>Reshape the 2d <code>MAT</code> to make only a single <code>ROW</code> visible. This is made
possible by the row-major layout, hence no column counterpart.
Return <code>MAT</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AWITH-SHAPE-AND-DISPLACEMENT-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p>[macro] <strong>WITH-SHAPE-AND-DISPLACEMENT</strong> <em>(MAT &amp;OPTIONAL (DIMENSIONS NIL DIMENSIONSP) (DISPLACEMENT NIL DISPLACEMENTP)) &amp;BODY BODY</em></p>

<p>Reshape and displace <code>MAT</code> if <code>DIMENSIONS</code> and/or <code>DISPLACEMENT</code> is given
and restore the original shape and displacement after <code>BODY</code> is
executed. If neither is specificed, then nothing will be changed,
but <code>BODY</code> is still allowed to alter the shape and displacement.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AADJUST-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>ADJUST!</strong> <em>MAT DIMENSIONS DISPLACEMENT &amp;KEY (DESTROY-OLD-P T)</em></p>

<p>Like <a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-AND-DISPLACE! FUNCTION)"><code>RESHAPE-AND-DISPLACE!</code></a> but creates a new matrix if <code>MAT</code> isn't
large enough. If a new matrix is created, the contents are not
copied over and the old matrix is destroyed with <a href="cube-manual.html#x-28MGL-CUBE-3ADESTROY-CUBE-20FUNCTION-29" title="(MGL-CUBE:DESTROY-CUBE FUNCTION)"><code>DESTROY-CUBE</code></a> if
<code>DESTROY-OLD-P</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-SHAPING MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CACHING MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-ASSEMBLING MGL-PAX:SECTION)">&#8634;</a></span>7 Assembling</h2>

<p>The functions here assemble a single <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> from a number of
<a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a>s.</p>

<p><a name='x-28MGL-MAT-3ASTACK-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>STACK!</strong> <em>AXIS MATS MAT</em></p>

<p>Stack <code>MATS</code> along <code>AXIS</code> into <code>MAT</code> and return <code>MAT</code>. If <code>AXIS</code> is 0, place
<code>MATS</code> into <code>MAT</code> below each other starting from the top. If <code>AXIS</code> is 1,
place <code>MATS</code> side by side starting from the left. Higher <code>AXIS</code> are also
supported. All dimensions except for <code>AXIS</code> must be the same for all
<code>MATS</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ASTACK-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>STACK</strong> <em>AXIS MATS &amp;KEY (CTYPE *DEFAULT-MAT-CTYPE*)</em></p>

<p>Like <a href="#x-28MGL-MAT-3ASTACK-21-20FUNCTION-29" title="(MGL-MAT:STACK! FUNCTION)"><code>STACK!</code></a> but return a new <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> of <code>CTYPE</code>.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">stack 1 <span class="paren2">(<span class="code">list <span class="paren3">(<span class="code">make-mat '<span class="paren4">(<span class="code">3 2</span>)</span> <span class="keyword">:initial-element</span> 0</span>)</span>
               <span class="paren3">(<span class="code">make-mat '<span class="paren4">(<span class="code">3 1</span>)</span> <span class="keyword">:initial-element</span> 1</span>)</span></span>)</span></span>)</span>
==&gt; #&lt;MAT 3x3 B #2A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span>
--&gt;                 <span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span>
--&gt;                 <span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span></span>)</span>&gt;</span></code></pre></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-ASSEMBLING MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-FOREIGN MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CACHING MGL-PAX:SECTION)">&#8634;</a></span>8 Caching</h2>

<p>Allocating and initializing a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> object and its necessary facets
can be expensive. The following macros remember the previous value
of a binding in the same thread and /place/. Only weak references
are constructed so the cached objects can be garbage collected.</p>

<p>While the cache is global, thread safety is guaranteed by having
separate subcaches per thread. Each subcache is keyed by a /place/
object that's either explicitly specified or else is unique to each
invocation of the caching macro, so different occurrences of caching
macros in the source never share data. Still, recursion could lead
to data sharing between different invocations of the same function.
To prevent this, the cached object is removed from the cache while
it is used so other invocations will create a fresh one which isn't
particularly efficient but at least it's safe.</p>

<p><a name='x-28MGL-MAT-3AWITH-THREAD-CACHED-MAT-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p>[macro] <strong>WITH-THREAD-CACHED-MAT</strong> <em>(VAR DIMENSIONS &amp;REST ARGS &amp;KEY (PLACE :SCRATCH) (CTYPE '*DEFAULT-MAT-CTYPE*) (DISPLACEMENT 0) MAX-SIZE (INITIAL-ELEMENT 0) INITIAL-CONTENTS) &amp;BODY BODY</em></p>

<p>Bind <code>VAR</code> to a matrix of <code>DIMENSIONS</code>, <code>CTYPE</code>, etc. Cache this matrix,
and possibly reuse it later by reshaping it. When <code>BODY</code> exits the
cached object is updated with the binding of <code>VAR</code> which <code>BODY</code> may
change.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AWITH-ONES-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p>[macro] <strong>WITH-ONES</strong> <em>(VAR DIMENSIONS &amp;KEY (CTYPE '*DEFAULT-MAT-CTYPE*) (PLACE :ONES)) &amp;BODY BODY</em></p>

<p>Bind <code>VAR</code> to a matrix of <code>DIMENSIONS</code> whose every element is 1. The
matrix is cached for efficiency.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CACHING MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUDA MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-FOREIGN MGL-PAX:SECTION)">&#8634;</a></span>9 Foreign arrays</h2>

<p>One facet of <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects is <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>FOREIGN-ARRAY</code></a> which is
backed by a memory area that can be pinned or is allocated in
foreign memory depending on <a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" title="(MGL-MAT:*FOREIGN-ARRAY-STRATEGY* (VARIABLE \&quot;-see below-\&quot;))"><code>*FOREIGN-ARRAY-STRATEGY*</code></a>.</p>

<p><a name='x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29'></a></p>

<ul>
<li><p>[class] <strong>FOREIGN-ARRAY</strong> <em>OFFSET-POINTER</em></p>

<p><a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>FOREIGN-ARRAY</code></a> wraps a foreign pointer (in
the sense of <code>CFFI:POINTERP</code>). That is, both <code>OFFSET-POINTER</code> and
<code>BASE-POINTER</code> return a foreign pointer. There are no other public
operations that work with <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>FOREIGN-ARRAY</code></a> objects, their sole
purpose is represent facets of <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29'></a></p>

<ul>
<li><p>[variable] <strong>*FOREIGN-ARRAY-STRATEGY*</strong> <em>&quot;-see below-&quot;</em></p>

<p>One of <code>:PIN-BACKING-ARRAY</code>, <code>:STATIC-BACKING-ARRAY</code> and :ALLOCATE (see
type <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-STRATEGY-20TYPE-29" title="(MGL-MAT:FOREIGN-ARRAY-STRATEGY TYPE)"><code>FOREIGN-ARRAY-STRATEGY</code></a>). This variable controls how foreign
arrays are handled and it can be changed at any time.</p>

<p>If it's <code>:PIN-BACKING-ARRAY</code> (only supported if (<a href="#x-28MGL-MAT-3APINNING-SUPPORTED-P-20FUNCTION-29" title="(MGL-MAT:PINNING-SUPPORTED-P FUNCTION)"><code>PINNING-SUPPORTED-P</code></a>),
then no separate storage is allocated for the foreign array, instead
it aliases the lisp array (via the <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> facet).</p>

<p>If it's <code>:STATIC-BACKING-ARRAY</code>, then the lisp backing arrays are
allocated statically via the static-vectors library. On some
implementations, explicit freeing of static vectors is necessary,
this is taken care of by finalizers or can be controlled with
<a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-BARRIER-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET-BARRIER MGL-PAX:MACRO)"><code>WITH-FACET-BARRIER</code></a>.</p>

<p>If it's <code>:DYNAMIC</code>, then each time the foreign array is needed, it's
allocated and freed dynamically.</p>

<p>The default is <code>:PIN-BACKING-ARRAY</code> if available, because it's the most
effecient. If pinning is not available, then
it's <code>:STATIC-BACKING-ARRAY</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AFOREIGN-ARRAY-STRATEGY-20TYPE-29'></a></p>

<ul>
<li><p>[type] <strong>FOREIGN-ARRAY-STRATEGY</strong></p>

<p>One of <code>:PIN-BACKING-ARRAY</code>, <code>:STATIC-BACKING-ARRAY</code>, <code>:DYNAMIC</code>. See
<a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" title="(MGL-MAT:*FOREIGN-ARRAY-STRATEGY* (VARIABLE \&quot;-see below-\&quot;))"><code>*FOREIGN-ARRAY-STRATEGY*</code></a> for their semantics.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3APINNING-SUPPORTED-P-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>PINNING-SUPPORTED-P</strong> </p>

<p>Return true iff the lisp implementation efficiently supports
pinning lisp arrays. Pinning ensures that the garbage collector
doesn't move the array in memory. Currently this is only supported on
SBCL gencgc platforms.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-FOREIGN MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUBLAS MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUDA MGL-PAX:SECTION)">&#8634;</a></span>10 CUDA</h2>

<p><a name='x-28MGL-MAT-3ACUDA-AVAILABLE-P-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>CUDA-AVAILABLE-P</strong> <em>&amp;KEY (DEVICE-ID 0)</em></p>

<p>Check a cuda context is already in initialized in the current
thread or a device with <code>DEVICE-ID</code> is available.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p>[macro] <strong>WITH-CUDA*</strong> <em>(&amp;KEY (ENABLED '*CUDA-ENABLED*) (DEVICE-ID *CUDA-DEFAULT-DEVICE-ID*) (RANDOM-SEED *CUDA-DEFAULT-RANDOM-SEED*) (N-RANDOM-STATES *CUDA-DEFAULT-N-RANDOM-STATES*) (OVERRIDE-ARCH-P T)) &amp;BODY BODY</em></p>

<p>Initializes cuda with with all bells and whistles before <code>BODY</code> and
deinitializes it after. Simply wrapping <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a> around a piece
code is enough to make use of the first available cuda device or
fall back on blas and lisp kernels if there is none.</p>

<p>If cuda is already initialized, then it sets up a facet barrier
which destroys <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facets after ensuring that the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet
is up-to-date.</p>

<p>Else, if cuda is available and <code>ENABLED</code>, then in addition to the
facet barrier, a cuda context is set up, <a href="#x-28MGL-MAT-3A-2AN-MEMCPY-HOST-TO-DEVICE-2A-20VARIABLE-29" title="(MGL-MAT:*N-MEMCPY-HOST-TO-DEVICE* VARIABLE)"><code>*N-MEMCPY-HOST-TO-DEVICE*</code></a>,
<a href="#x-28MGL-MAT-3A-2AN-MEMCPY-DEVICE-TO-HOST-2A-20VARIABLE-29" title="(MGL-MAT:*N-MEMCPY-DEVICE-TO-HOST* VARIABLE)"><code>*N-MEMCPY-DEVICE-TO-HOST*</code></a> are bound to zero, the highest possible
-arch option for the device is added to <em>CL-CUDA:NVCC-OPTIONS</em> (if
<code>OVERRIDE-ARCH-P</code>), a cublas handle created, and <a href="#x-28MGL-MAT-3A-2ACURAND-STATE-2A-20VARIABLE-29" title="(MGL-MAT:*CURAND-STATE* VARIABLE)"><code>*CURAND-STATE*</code></a> is
bound to a <a href="#x-28MGL-MAT-3ACURAND-XORWOW-STATE-20CLASS-29" title="(MGL-MAT:CURAND-XORWOW-STATE CLASS)"><code>CURAND-XORWOW-STATE</code></a> with <code>N-RANDOM-STATES</code>, seeded with
<code>RANDOM-SEED</code>.</p>

<p>Else - that is, if cuda is not available -, <code>BODY</code> is simply
executed.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACALL-WITH-CUDA-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>CALL-WITH-CUDA</strong> <em>FN &amp;KEY ((:ENABLED *CUDA-ENABLED*) *CUDA-ENABLED*) (DEVICE-ID *CUDA-DEFAULT-DEVICE-ID*) (RANDOM-SEED *CUDA-DEFAULT-RANDOM-SEED*) (N-RANDOM-STATES *CUDA-DEFAULT-N-RANDOM-STATES*) (OVERRIDE-ARCH-P T)</em></p>

<p>Like <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>, but takes a no argument function instead of the
macro's <code>BODY</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*CUDA-ENABLED*</strong> <em>T</em></p>

<p>Set or bind this to false to disable all use of cuda. If this is
done from within <code>WITH-CUDA</code><em>, then cuda becomes temporarily disabled.
If this is done from outside <code>WITH-CUDA</code></em>, then it changes the default
values of the <code>ENABLED</code> argument of any future <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>s which
turns off cuda initialization entirely.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>USE-CUDA-P</strong> </p>

<p>Return true if cuda is enabled (<a href="#x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-ENABLED* VARIABLE)"><code>*CUDA-ENABLED*</code></a>) and it's
initialized. <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> operations use this to decide whether to go for the
cuda implementation or BLAS/Lisp. It's provided for implementing new
operations.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2AN-MEMCPY-HOST-TO-DEVICE-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*N-MEMCPY-HOST-TO-DEVICE*</strong> <em>0</em></p>

<p>Incremented each time a host to device copy is performed. Bound to
0 by <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>. Useful for tracking down performance problems.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2AN-MEMCPY-DEVICE-TO-HOST-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*N-MEMCPY-DEVICE-TO-HOST*</strong> <em>0</em></p>

<p>Incremented each time a device to host copy is performed. Bound to
0 by <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>. Useful for tracking down performance problems.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACHOOSE-1D-BLOCK-AND-GRID-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>CHOOSE-1D-BLOCK-AND-GRID</strong> <em>N MAX-N-WARPS-PER-BLOCK</em></p>

<p>Return two values, one suitable as the <code>:BLOCK-DIM</code>, the other as
the <code>:GRID-DIM</code> argument for a cuda kernel call where both are
one-dimensional (only the first element may be different from 1).</p>

<p>The number of threads in a block is a multiple of <code>*CUDA-WARP-SIZE*</code>.
The number of blocks is between 1 and and <code>*CUDA-MAX-N-BLOCKS*</code>. This
means that the kernel must be able handle any number of elements in
each thread. For example, a strided kernel that adds a constant to
each element of a length <code>N</code> vector looks like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">stride <span class="paren4">(<span class="code">* block-dim-x grid-dim-x</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">do <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">i <span class="paren5">(<span class="code">+ <span class="paren6">(<span class="code">* block-dim-x block-idx-x</span>)</span> thread-idx-x</span>)</span>
          <span class="paren5">(<span class="code">+ i stride</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">&gt;= i n</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">set <span class="paren4">(<span class="code">aref x i</span>)</span> <span class="paren4">(<span class="code">+ <span class="paren5">(<span class="code">aref x i</span>)</span> alpha</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>It is often the most efficient to have <code>MAX-N-WARPS-PER-BLOCK</code> around
4. Note that the maximum number of threads per block is limited by
hardware (512 for compute capability &lt; 2.0, 1024 for later
versions), so <code>*CUDA-MAX-N-BLOCKS*</code> times <code>MAX-N-WARPS-PER-BLOCK</code> must
not exceed that limit.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACHOOSE-2D-BLOCK-AND-GRID-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>CHOOSE-2D-BLOCK-AND-GRID</strong> <em>DIMENSIONS MAX-N-WARPS-PER-BLOCK</em></p>

<p>Return two values, one suitable as the <code>:BLOCK-DIM</code>, the other as
the <code>:GRID-DIM</code> argument for a cuda kernel call where both are
two-dimensional (only the first two elements may be different from
1).</p>

<p>The number of threads in a block is a multiple of <code>*CUDA-WARP-SIZE*</code>.
The number of blocks is between 1 and and <code>*CUDA-MAX-N-BLOCKS*</code>.
Currently - but this may change - the <code>BLOCK-DIM-X</code> is always
<code>*CUDA-WARP-SIZE*</code> and <code>GRID-DIM-X</code> is always 1.</p>

<p>This means that the kernel must be able handle any number of
elements in each thread. For example, a strided kernel that adds a
constant to each element of a HEIGHT*WIDTH matrix looks like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">id-x <span class="paren4">(<span class="code">+ <span class="paren5">(<span class="code">* block-dim-x block-idx-x</span>)</span> thread-idx-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">id-y <span class="paren4">(<span class="code">+ <span class="paren5">(<span class="code">* block-dim-y block-idx-y</span>)</span> thread-idx-y</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-x <span class="paren4">(<span class="code">* block-dim-x grid-dim-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-y <span class="paren4">(<span class="code">* block-dim-y grid-dim-y</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">do <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">row id-y <span class="paren5">(<span class="code">+ row stride-y</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">&gt;= row height</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">i <span class="paren6">(<span class="code">* row width</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">do <span class="paren5">(<span class="code"><span class="paren6">(<span class="code">column id-x <span class="paren1">(<span class="code">+ column stride-x</span>)</span></span>)</span></span>)</span>
          <span class="paren5">(<span class="code"><span class="paren6">(<span class="code">&gt;= column width</span>)</span></span>)</span>
        <span class="paren5">(<span class="code">set <span class="paren6">(<span class="code">aref x i</span>)</span> <span class="paren6">(<span class="code">+ <span class="paren1">(<span class="code">aref x i</span>)</span> alpha</span>)</span></span>)</span>
        <span class="paren5">(<span class="code">incf i stride-x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre></li>
</ul>

<p><a name='x-28MGL-MAT-3ACHOOSE-3D-BLOCK-AND-GRID-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>CHOOSE-3D-BLOCK-AND-GRID</strong> <em>DIMENSIONS MAX-N-WARPS-PER-BLOCK</em></p>

<p>Return two values, one suitable as the <code>:BLOCK-DIM</code>, the other as
the <code>:GRID-DIM</code> argument for a cuda kernel call where both are
two-dimensional (only the first two elements may be different from
1).</p>

<p>The number of threads in a block is a multiple of <code>*CUDA-WARP-SIZE*</code>.
The number of blocks is between 1 and and <code>*CUDA-MAX-N-BLOCKS*</code>.
Currently - but this may change - the <code>BLOCK-DIM-X</code> is always
<code>*CUDA-WARP-SIZE*</code> and <code>GRID-DIM-X</code> is always 1.</p>

<p>This means that the kernel must be able handle any number of
elements in each thread. For example, a strided kernel that adds a
constant to each element of a <code>THICKNESS</code> * <code>HEIGHT</code> * <code>WIDTH</code> 3d array
looks like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">id-x <span class="paren4">(<span class="code">+ <span class="paren5">(<span class="code">* block-dim-x block-idx-x</span>)</span> thread-idx-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">id-y <span class="paren4">(<span class="code">+ <span class="paren5">(<span class="code">* block-dim-y block-idx-y</span>)</span> thread-idx-y</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">id-z <span class="paren4">(<span class="code">+ <span class="paren5">(<span class="code">* block-dim-z block-idx-z</span>)</span> thread-idx-z</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-x <span class="paren4">(<span class="code">* block-dim-x grid-dim-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-y <span class="paren4">(<span class="code">* block-dim-y grid-dim-y</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-z <span class="paren4">(<span class="code">* block-dim-z grid-dim-z</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">do <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">plane id-z <span class="paren5">(<span class="code">+ plane stride-z</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">&gt;= plane thickness</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">do <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">row id-y <span class="paren6">(<span class="code">+ row stride-y</span>)</span></span>)</span></span>)</span>
        <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">&gt;= row height</span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren5">(<span class="code"><span class="paren6">(<span class="code">i <span class="paren1">(<span class="code">* <span class="paren2">(<span class="code">+ <span class="paren3">(<span class="code">* plane height</span>)</span> row</span>)</span>
                  width</span>)</span></span>)</span></span>)</span>
        <span class="paren5">(<span class="code">do <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">column id-x <span class="paren2">(<span class="code">+ column stride-x</span>)</span></span>)</span></span>)</span>
            <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">&gt;= column width</span>)</span></span>)</span>
          <span class="paren6">(<span class="code">set <span class="paren1">(<span class="code">aref x i</span>)</span> <span class="paren1">(<span class="code">+ <span class="paren2">(<span class="code">aref x i</span>)</span> alpha</span>)</span></span>)</span>
          <span class="paren6">(<span class="code">incf i stride-x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre></li>
</ul>

<p><a name='x-28MGL-MAT-3ACUDA-OUT-OF-MEMORY-20CONDITION-29'></a></p>

<ul>
<li>[condition] <strong>CUDA-OUT-OF-MEMORY</strong> <em>STORAGE-CONDITION</em></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ACUDA-DEFAULT-DEVICE-ID-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*CUDA-DEFAULT-DEVICE-ID*</strong> <em>0</em></p>

<p>The default value of <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>'s <code>:DEVICE-ID</code> argument.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ACUDA-DEFAULT-RANDOM-SEED-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*CUDA-DEFAULT-RANDOM-SEED*</strong> <em>1234</em></p>

<p>The default value of <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>'s <code>:RANDOM-SEED</code> argument.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ACUDA-DEFAULT-N-RANDOM-STATES-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*CUDA-DEFAULT-N-RANDOM-STATES*</strong> <em>4096</em></p>

<p>The default value of <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>'s <code>:N-RANDOM-STATES</code> argument.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29'></a></p>

<h3><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUDA MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUDA MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CURAND MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUBLAS MGL-PAX:SECTION)">&#8634;</a></span>10.1 CUBLAS</h3>

<p><a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a> should take of everything. No need to use these at all
unless you have a very good reason to bypass it.</p>

<p><a name='x-28MGL-MAT-3ACUBLAS-ERROR-20CONDITION-29'></a></p>

<ul>
<li>[condition] <strong>CUBLAS-ERROR</strong> <em>ERROR</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ACUBLAS-ERROR-FUNCTION-NAME-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACUBLAS-ERROR-29-29'></a></p>

<ul>
<li>[reader] <strong>CUBLAS-ERROR-FUNCTION-NAME</strong> <em>CUBLAS-ERROR</em> <em>(:FUNCTION-NAME)</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ACUBLAS-ERROR-STATUS-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACUBLAS-ERROR-29-29'></a></p>

<ul>
<li>[reader] <strong>CUBLAS-ERROR-STATUS</strong> <em>CUBLAS-ERROR</em> <em>(:STATUS)</em></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ACUBLAS-HANDLE-2A-20VARIABLE-29'></a></p>

<ul>
<li>[variable] <strong>*CUBLAS-HANDLE*</strong> <em>&quot;-unbound-&quot;</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ACUBLAS-CREATE-20FUNCTION-29'></a></p>

<ul>
<li>[function] <strong>CUBLAS-CREATE</strong> <em>HANDLE</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ACUBLAS-DESTROY-20FUNCTION-29'></a></p>

<ul>
<li>[function] <strong>CUBLAS-DESTROY</strong> <em>&amp;KEY (HANDLE *CUBLAS-HANDLE*)</em></li>
</ul>

<p><a name='x-28MGL-MAT-3AWITH-CUBLAS-HANDLE-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li>[macro] <strong>WITH-CUBLAS-HANDLE</strong> <em>NIL &amp;BODY BODY</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ACUBLAS-GET-VERSION-20FUNCTION-29'></a></p>

<ul>
<li>[function] <strong>CUBLAS-GET-VERSION</strong> <em>VERSION &amp;KEY (HANDLE *CUBLAS-HANDLE*)</em></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29'></a></p>

<h3><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUBLAS MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CUDA MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BLAS MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CURAND MGL-PAX:SECTION)">&#8634;</a></span>10.2 CURAND</h3>

<p>This the low level CURAND API.</p>

<p><a name='x-28MGL-MAT-3AWITH-CURAND-STATE-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li>[macro] <strong>WITH-CURAND-STATE</strong> <em>(STATE) &amp;BODY BODY</em></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ACURAND-STATE-2A-20VARIABLE-29'></a></p>

<ul>
<li>[variable] <strong>*CURAND-STATE*</strong> <em>&quot;-unbound-&quot;</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ACURAND-XORWOW-STATE-20CLASS-29'></a></p>

<ul>
<li>[class] <strong>CURAND-XORWOW-STATE</strong> <em>CURAND-STATE</em></li>
</ul>

<p><a name='x-28MGL-MAT-3AN-STATES-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACURAND-XORWOW-STATE-29-29'></a></p>

<ul>
<li>[reader] <strong>N-STATES</strong> <em>CURAND-XORWOW-STATE</em> <em>(:N-STATES)</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ASTATES-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACURAND-XORWOW-STATE-29-29'></a></p>

<ul>
<li>[reader] <strong>STATES</strong> <em>CURAND-XORWOW-STATE</em> <em>(:STATES)</em></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-CURAND MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-DESTRUCTIVE-API MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BLAS MGL-PAX:SECTION)">&#8634;</a></span>11 BLAS</h2>

<p>Only some BLAS functions are implemented, but it should be easy to
add more as needed. All of them default to using CUDA, if it is
initialized and enabled (see <a href="#x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29" title="(MGL-MAT:USE-CUDA-P FUNCTION)"><code>USE-CUDA-P</code></a>).</p>

<p>Level 1 BLAS operations</p>

<p><a name='x-28MGL-MAT-3AASUM-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>ASUM</strong> <em>X &amp;KEY (N (MAT-SIZE X)) (INCX 1)</em></p>

<p>Return the l1 norm of <code>X</code>, that is, sum of the absolute values of its
elements.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AAXPY-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>AXPY!</strong> <em>ALPHA X Y &amp;KEY (N (MAT-SIZE X)) (INCX 1) (INCY 1)</em></p>

<p>Set <code>Y</code> to <code>ALPHA</code> * <code>X</code> + <code>Y</code>. Return <code>Y</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACOPY-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>COPY!</strong> <em>X Y &amp;KEY (N (MAT-SIZE X)) (INCX 1) (INCY 1)</em></p>

<p>Copy <code>X</code> into <code>Y</code>. Return <code>Y</code>.</p></li>
</ul>

<p><a name='x-28CL-CUDA-2ELANG-2EBUILT-IN-3ADOT-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>DOT</strong> <em>X Y &amp;KEY (N (MAT-SIZE X)) (INCX 1) (INCY 1)</em></p>

<p>Return the dot product of <code>X</code> and <code>Y</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ANRM2-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>NRM2</strong> <em>X &amp;KEY (N (MAT-SIZE X)) (INCX 1)</em></p>

<p>Return the l2 norm of <code>X</code>, which is the square root of the sum of the
squares of its elements.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ASCAL-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>SCAL!</strong> <em>ALPHA X &amp;KEY (N (MAT-SIZE X)) (INCX 1)</em></p>

<p>Set <code>X</code> to <code>ALPHA</code> * <code>X</code>. Return <code>X</code>.</p></li>
</ul>

<p>Level 3 BLAS operations</p>

<p><a name='x-28MGL-MAT-3AGEMM-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>GEMM!</strong> <em>ALPHA A B BETA C &amp;KEY TRANSPOSE-A? TRANSPOSE-B? M N K LDA LDB LDC</em></p>

<p>Basically <code>C</code> = <code>ALPHA</code> * <code>A</code>' * <code>B</code>' + <code>BETA</code> * <code>C</code>. <code>A</code>' is <code>A</code> or its transpose
depending on <code>TRANSPOSE-A?</code>. <code>B</code>' is <code>B</code> or its transpose depending on
<code>TRANSPOSE-B?</code>. Returns <code>C</code>.</p>

<p><code>A</code>' is an MxK matrix. <code>B</code>' is a KxN matrix. <code>C</code> is an MxN matrix.</p>

<p><code>LDA</code> is the width of the matrix <code>A</code> (not of <code>A</code>'). If <code>A</code> is not transposed,
then <code>K</code> &lt;= <code>LDA</code>, if it's transposed then <code>M</code> &lt;= <code>LDA</code>.</p>

<p><code>LDB</code> is the width of the matrix <code>B</code> (not of <code>B</code>'). If <code>B</code> is not transposed,
then <code>N</code> &lt;= <code>LDB</code>, if it's transposed then <code>K</code> &lt;= <code>LDB</code>.</p>

<p>In the example below M=3, N=2, K=5, LDA=6, LDB=3, LDC=4. The cells
marked with + do not feature in the calculation.</p>

<pre><code>           N
          --+
          --+
        K -B+
          --+
          --+
          +++
    K
  -----+  --++
M --A--+  -C++
  -----+  --++
  ++++++  ++++
</code></pre></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-BLAS MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-NON-DESTRUCTIVE-API MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-DESTRUCTIVE-API MGL-PAX:SECTION)">&#8634;</a></span>12 Destructive API</h2>

<p><a name='x-28MGL-MAT-3A-2ESQUARE-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.SQUARE!</strong> <em>X &amp;KEY (N (MAT-SIZE X))</em></p>

<p>Set <code>X</code> to its elementwise square. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ESQRT-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.SQRT!</strong> <em>X &amp;KEY (N (MAT-SIZE X))</em></p>

<p>Set <code>X</code> to its elementwise square root. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ELOG-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.LOG!</strong> <em>X &amp;KEY (N (MAT-SIZE X))</em></p>

<p>Set <code>X</code> to its elementwise natural logarithm. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2EEXP-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.EXP!</strong> <em>X &amp;KEY (N (MAT-SIZE X))</em></p>

<p>Apply <code>EXP</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ELOGISTIC-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.LOGISTIC!</strong> <em>X &amp;KEY (N (MAT-SIZE X))</em></p>

<p>Destructively apply the logistic function to <code>X</code> in an elementwise
manner. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2E-2B-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.+!</strong> <em>ALPHA X</em></p>

<p>Add the scalar <code>ALPHA</code> to each element of <code>X</code> destructively modifying
<code>X</code>. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2E-2A-21-20FUNCTION-29'></a></p>

<ul>
<li>[function] <strong>.*!</strong> <em>X Y</em></li>
</ul>

<p><a name='x-28MGL-MAT-3AGEEM-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>GEEM!</strong> <em>ALPHA A B BETA C</em></p>

<p>Like <a href="#x-28MGL-MAT-3AGEMM-21-20FUNCTION-29" title="(MGL-MAT:GEMM! FUNCTION)"><code>GEMM!</code></a>, but multiplication is elementwise. This is not a
standard BLAS routine.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AGEERV-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>GEERV!</strong> <em>ALPHA A X BETA B</em></p>

<p>GEneric Elementwise Row - Vector multiplication. <code>B</code> = beta * <code>B</code> + alpha * a
* diag(x). In other words, perform elementwise multiplication on
each row of <code>A</code> with the vector <code>X</code> and add the scaled result to the
corresponding row of <code>B</code>. Return <code>B</code>. This is not a standard BLAS
routine.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2E-3C-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.&lt;!</strong> <em>X Y</em></p>

<p>For each element of <code>X</code> and <code>Y</code> set <code>Y</code> to 1 if the element in <code>Y</code> is
greater than the element in <code>X</code>, and to 0 otherwise. Return <code>Y</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2EMIN-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.MIN!</strong> <em>ALPHA X</em></p>

<p>Set each element of <code>X</code> to <code>ALPHA</code> if it's greater than <code>ALPHA</code>. Return
<code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2EMAX-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>.MAX!</strong> <em>ALPHA X</em></p>

<p>Set each element of <code>X</code> to <code>ALPHA</code> if it's less than <code>ALPHA</code>. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AADD-SIGN-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>ADD-SIGN!</strong> <em>ALPHA A BETA B</em></p>

<p>Add the elementwise sign (-1, 0 or 1 for negative, zero and
positive numbers respectively) of <code>A</code> times <code>ALPHA</code> to <code>BETA</code> * <code>B</code>. Return
<code>B</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AFILL-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>FILL!</strong> <em>ALPHA X &amp;KEY (N (MAT-SIZE X))</em></p>

<p>Fill matrix <code>X</code> with <code>ALPHA</code>. Return <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ASUM-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>SUM!</strong> <em>X Y &amp;KEY AXIS (ALPHA 1) (BETA 0)</em></p>

<p>Sum matrix <code>X</code> along <code>AXIS</code> and add <code>ALPHA</code> * SUMS to <code>BETA</code> * <code>Y</code>
destructively modifying <code>Y</code>. Return <code>Y</code>. On a 2d matrix (nothing else is
supported currently), if <code>AXIS</code> is 0, then columns are summed, if <code>AXIS</code>
is 1 then rows are summed.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ASCALE-ROWS-21-20FUNCTION-29'></a></p>

<ul>
<li>[function] <strong>SCALE-ROWS!</strong> <em>SCALES A B</em></li>
</ul>

<p>Finally, some neural network operations.</p>

<p><a name='x-28MGL-MAT-3ACONVOLVE-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>CONVOLVE!</strong> <em>X W Y &amp;KEY START STRIDE ANCHOR BATCHED</em></p>

<p><code>Y</code> = <code>Y</code> + conv(<code>X</code>, <code>W</code>) and return <code>Y</code>. If <code>BATCHED</code>, then the first
dimension of <code>X</code> and <code>Y</code> is the number of elements in the batch (B),
else B is assumed to be 1. The rest of the dimensions encode the
input (<code>X</code>) and output (Y} N dimensional feature maps. <code>START</code>, <code>STRIDE</code>
and <code>ANCHOR</code> are lists of length N. <code>START</code> is the multi-dimensional
index of the first element of the input feature map (for each
element in the batch) for which the convolution must be computed.
Then (<code>ELT</code> <code>STRIDE</code> (- N 1)) is added to the last element of <code>START</code> and
so on until (<code>ARRAY-DIMENSION</code> <code>X</code> 1) is reached. Then the last element
of <code>START</code> is reset, (<code>ELT</code> <code>STRIDE</code> (- N 2)) is added to the first but
last element of <code>START</code> and we scan the last dimension again. Take a
2d example, <code>START</code> is (0 0), <code>STRIDE</code> is (1 2), and <code>X</code> is a B*2x7
matrix.</p>

<p><code>W</code> is:</p>

<pre><code>1 2 1
2 4 2
1 2 1
</code></pre>

<p>and <code>ANCHOR</code> is (1 1) which refers to the element of <code>W</code> whose value is
4. This anchor point of <code>W</code> is placed over elements of <code>X</code> whose multi
dimensional index is in numbers in this figure (only one element in
the batch is shown):</p>

<pre><code>0,0 . 0,2 . 0,4 . 0,6
1,0 . 1,2 . 1,4 . 1,6
</code></pre>

<p>When applying <code>W</code> at position P of <code>X</code>, the convolution is the sum of
the products of overlapping elements of <code>X</code> and <code>W</code> when <code>W</code>'s <code>ANCHOR</code> is
placed at P. Elements of <code>W</code> over the edges of <code>X</code> are multiplied with 0
so are effectively ignored. The order of application of <code>W</code> to
positions defined by <code>START</code>, <code>STRIDE</code> and <code>ANCHOR</code> is undefined.</p>

<p><code>Y</code> must be a B*2x4 (or 2x4 if not <code>BATCHED</code>) matrix in this example,
just large enough to hold the results of the convolutions.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ADERIVE-CONVOLVE-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>DERIVE-CONVOLVE!</strong> <em>X XD W WD YD &amp;KEY START STRIDE ANCHOR BATCHED</em></p>

<p>Add the dF/dX to <code>XD</code> and and dF/dW to <code>WD</code> where <code>YD</code> is dF/dY for some
function F where Y is the result of convolution with the same
arguments. </p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAX-POOL-21-20FUNCTION-29'></a></p>

<ul>
<li>[function] <strong>MAX-POOL!</strong> <em>X Y &amp;KEY START STRIDE ANCHOR BATCHED POOL-DIMENSIONS</em></li>
</ul>

<p><a name='x-28MGL-MAT-3ADERIVE-MAX-POOL-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>DERIVE-MAX-POOL!</strong> <em>X XD Y YD &amp;KEY START STRIDE ANCHOR BATCHED POOL-DIMENSIONS</em></p>

<p>Add the dF/dX to <code>XD</code> and and dF/dW to WD where <code>YD</code> is dF/dY for some
function F where <code>Y</code> is the result of <a href="#x-28MGL-MAT-3AMAX-POOL-21-20FUNCTION-29" title="(MGL-MAT:MAX-POOL! FUNCTION)"><code>MAX-POOL!</code></a> with the same
arguments. </p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-DESTRUCTIVE-API MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MAPPINGS MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-NON-DESTRUCTIVE-API MGL-PAX:SECTION)">&#8634;</a></span>13 Non-destructive API</h2>

<p><a name='x-28MGL-MAT-3ACOPY-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>COPY-MAT</strong> <em>A</em></p>

<p>Return a copy of the active portion with regards to displacement
and shape of <code>A</code>. </p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACOPY-ROW-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>COPY-ROW</strong> <em>A ROW</em></p>

<p>Return <code>ROW</code> of <code>A</code> as a new 1d matrix.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACOPY-COLUMN-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>COPY-COLUMN</strong> <em>A COLUMN</em></p>

<p>Return <code>COLUMN</code> of <code>A</code> as a new 1d matrix.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAT-AS-SCALAR-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MAT-AS-SCALAR</strong> <em>A</em></p>

<p>Return the first element of <code>A</code>. <code>A</code> must be of size 1.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ASCALAR-AS-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>SCALAR-AS-MAT</strong> <em>X &amp;KEY (CTYPE (LISP-&gt;CTYPE (TYPE-OF X)))</em></p>

<p>Return a matrix of one dimension and one element: <code>X</code>. <code>CTYPE</code>, the
type of the matrix, defaults to the ctype corresponding to the type
of <code>X</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AM-3D-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>M=</strong> <em>A B</em></p>

<p>Check whether <code>A</code> and <code>B</code>, which must be matrices of the same size, are
elementwise equal.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ATRANSPOSE-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>TRANSPOSE</strong> <em>A</em></p>

<p>Return the transpose of <code>A</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AM-2A-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>M*</strong> <em>A B &amp;KEY TRANSPOSE-A? TRANSPOSE-B?</em></p>

<p>Compute op(<code>A</code>) * op(<code>B</code>). Where op is either the identity or the
transpose operation depending on <code>TRANSPOSE-A?</code> and <code>TRANSPOSE-B?</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AMM-2A-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MM*</strong> <em>M &amp;REST ARGS</em></p>

<p>Convenience function to multiply several matrices. </p>

<p>(mm* a b c) =&gt; a * b * c</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AM--20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>M-</strong> <em>A B</em></p>

<p>Return <code>A</code> - <code>B</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AM-2B-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>M+</strong> <em>A B</em></p>

<p>Return <code>A</code> + <code>B</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AINVERT-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>INVERT</strong> <em>A</em></p>

<p>Return the inverse of <code>A</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ALOGDET-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>LOGDET</strong> <em>MAT</em></p>

<p>Logarithm of the determinant of a matrix. Return -1, 1 or 0 (or
equivalent) to correct for the sign, as a second value.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-NON-DESTRUCTIVE-API MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-RANDOM MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MAPPINGS MGL-PAX:SECTION)">&#8634;</a></span>14 Mappings</h2>

<p><a name='x-28MGL-MAT-3AMAP-CONCAT-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MAP-CONCAT</strong> <em>FN MATS MAT &amp;KEY KEY PASS-RAW-P</em></p>

<p>Call <code>FN</code> with each element of <code>MATS</code> and <code>MAT</code> temporarily reshaped to
the dimensions of the current element of <code>MATS</code> and return <code>MAT</code>. For
the next element the displacement is increased so that there is no
overlap.</p>

<p><code>MATS</code> is keyed by <code>KEY</code> just like the CL sequence functions. Normally,
<code>FN</code> is called with the matrix returned by <code>KEY</code>. However, if
<code>PASS-RAW-P</code>, then the matrix returned by <code>KEY</code> is only used to
calculate dimensions and the element of <code>MATS</code> that was passed to <code>KEY</code>
is passed to <code>FN</code>, too.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">map-concat #'copy! <span class="paren2">(<span class="code">list <span class="paren3">(<span class="code">make-mat 2</span>)</span> <span class="paren3">(<span class="code">make-mat 4 <span class="keyword">:initial-element</span> 1</span>)</span></span>)</span>
            <span class="paren2">(<span class="code">make-mat '<span class="paren3">(<span class="code">2 3</span>)</span></span>)</span></span>)</span>
==&gt; #&lt;MAT 2x3 AB #2A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span> <span class="paren2">(<span class="code">1.0d0 1.0d0 1.0d0</span>)</span></span>)</span>&gt;</span></code></pre></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAP-DISPLACEMENTS-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MAP-DISPLACEMENTS</strong> <em>FN MAT DIMENSIONS &amp;KEY (DISPLACEMENT-START 0) DISPLACEMENT-STEP</em></p>

<p>Call <code>FN</code> with <code>MAT</code> reshaped to <code>DIMENSIONS</code>, first displaced by
<code>DISPLACEMENT-START</code> that's incremented by <code>DISPLACEMENT-STEP</code> each
iteration while there are enough elements left for <code>DIMENSIONS</code> at the
current displacement. Returns <code>MAT</code>.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">mat <span class="paren4">(<span class="code">make-mat 14 <span class="keyword">:initial-contents</span> '<span class="paren5">(<span class="code">-1 0 1 2 3
                                            4 5 6 7
                                            8 9 10 11 12</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">reshape-and-displace! mat '<span class="paren3">(<span class="code">4 3</span>)</span> 1</span>)</span>
  <span class="paren2">(<span class="code">map-displacements #'print mat 4</span>)</span></span>)</span>
..
.. #&lt;MAT 1+4+9 B #<span class="paren1">(<span class="code">0.0d0 1.0d0 2.0d0 3.0d0</span>)</span>&gt; 
.. #&lt;MAT 5+4+5 B #<span class="paren1">(<span class="code">4.0d0 5.0d0 6.0d0 7.0d0</span>)</span>&gt; 
.. #&lt;MAT 9+4+1 B #<span class="paren1">(<span class="code">8.0d0 9.0d0 10.0d0 11.0d0</span>)</span>&gt; </span></code></pre></li>
</ul>

<p><a name='x-28MGL-MAT-3AMAP-MATS-INTO-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MAP-MATS-INTO</strong> <em>RESULT-MAT FN &amp;REST MATS</em></p>

<p>Like <code>CL:MAP-INTO</code> but for <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects. Destructively modifies
<code>RESULT-MAT</code> to contain the results of applying <code>FN</code> to each element in
the argument <code>MATS</code> in turn.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MAPPINGS MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-IO MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-RANDOM MGL-PAX:SECTION)">&#8634;</a></span>15 Random numbers</h2>

<p>This is rather experimental.</p>

<p><a name='x-28MGL-MAT-3AMV-GAUSSIAN-RANDOM-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>MV-GAUSSIAN-RANDOM</strong> <em>&amp;KEY MEANS COVARIANCES</em></p>

<p>Return a column vector of samples from the multivariate normal
distribution defined by <code>MEANS</code> (Nx1) and <code>COVARIANCES</code> (NxN).</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ACOPY-RANDOM-STATE-20GENERIC-FUNCTION-29'></a></p>

<ul>
<li><p>[generic-function] <strong>COPY-RANDOM-STATE</strong> <em>STATE</em></p>

<p>Return a copy of <code>STATE</code> be it a lisp or cuda random
state.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AUNIFORM-RANDOM-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>UNIFORM-RANDOM!</strong> <em>MAT &amp;KEY (LIMIT 1)</em></p>

<p>Fill <code>MAT</code> with random numbers sampled uniformly from the [0,LIMIT)
interval of <code>MAT</code>'s type.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AGAUSSIAN-RANDOM-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>GAUSSIAN-RANDOM!</strong> <em>MAT &amp;KEY (MEAN 0) (STDDEV 1)</em></p>

<p>Fill <code>MAT</code> with independent normally distributed random numbers with
<code>MEAN</code> and <code>STDDEV</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AORTHOGONAL-RANDOM-21-20FUNCTION-29'></a></p>

<ul>
<li><p>[function] <strong>ORTHOGONAL-RANDOM!</strong> <em>M &amp;KEY (SCALE 1)</em></p>

<p>Fill the matrix <code>M</code> with random values in such a way that <code>M^T * M</code>
is the identity matrix (or something close if <code>M</code> is wide). Return <code>M</code>.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-RANDOM MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSION-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-EXTENSION-API MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-IO MGL-PAX:SECTION)">&#8634;</a></span>16 I/O</h2>

<p><a name='x-28MGL-MAT-3AWRITE-MAT-20GENERIC-FUNCTION-29'></a></p>

<ul>
<li><p>[generic-function] <strong>WRITE-MAT</strong> <em>MAT STREAM</em></p>

<p>Write <code>MAT</code> to <code>STREAM</code> in portable binary format.
Displacement and size are taken into account, only visible elements
are written.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3AREAD-MAT-20GENERIC-FUNCTION-29'></a></p>

<ul>
<li><p>[generic-function] <strong>READ-MAT</strong> <em>MAT STREAM</em></p>

<p>Destructively modify the visible portion (with
regards to displacement and shape) of <code>MAT</code> by reading <a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> number
of elements from <code>STREAM</code>. No sanity checks are performed, <a href="#x-28MGL-MAT-3AREAD-MAT-20GENERIC-FUNCTION-29" title="(MGL-MAT:READ-MAT GENERIC-FUNCTION)"><code>READ-MAT</code></a>
may return without error even if <code>STREAM</code> contains garbage.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-EXTENSION-API-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-IO MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-DEBUGGING MGL-PAX:SECTION)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSION-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-EXTENSION-API MGL-PAX:SECTION)">&#8634;</a></span>17 Extension API</h2>

<p>Macros for defining cuda and lisp kernels. Typically operations
have a cuda and a lisp implementations and decide which to use with
<a href="#x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29" title="(MGL-MAT:USE-CUDA-P FUNCTION)"><code>USE-CUDA-P</code></a>. These are provided to help writing new operations.</p>

<p><a name='x-28MGL-MAT-3ADEFINE-LISP-KERNEL-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p>[macro] <strong>DEFINE-LISP-KERNEL</strong> <em>(NAME &amp;KEY (CTYPES '(:FLOAT :DOUBLE))) (&amp;REST PARAMS) &amp;BODY BODY</em></p>

<p>This is an extended <code>CL-CUDA:DEFKERNEL</code> macro. It knows how to deal
with <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects and can define the same function for multiple
<code>CTYPES</code>. Example:</p>

<pre><code>(define-lisp-kernel (lisp-.+!)
    ((alpha single-float) (x :mat :input) (start-x index) (n index))
  (loop for xi of-type index upfrom start-x
          below (the! index (+ start-x n))
        do (incf (aref x xi) alpha)))
</code></pre>

<p>Parameters are either of the form <code>(&lt;NAME&gt; &lt;LISP-TYPE)</code>
or <code>(&lt;NAME&gt; :MAT &lt;DIRECTION&gt;)</code>. In the latter case, the appropriate
CFFI:POINTER is passed to the kernel. <code>&lt;DIRECTION&gt;</code> is passed on to
the <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET MGL-PAX:MACRO)"><code>WITH-FACET</code></a> that's used to acquire the foreign array. Note that
the return type is not declared.</p>

<p>Both the signature and the body are written as if for single floats,
but one function is defined for each ctype in <code>CTYPES</code> by transforming
types, constants and code by substituting them with their ctype
equivalents. Currently this only means that one needs to write only
one kernel for <code>SINGLE-FLOAT</code> and <code>DOUBLE-FLOAT</code>. All such functions get
the declaration from <a href="#x-28MGL-MAT-3A-2ADEFAULT-LISP-KERNEL-DECLARATIONS-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-LISP-KERNEL-DECLARATIONS* VARIABLE)"><code>*DEFAULT-LISP-KERNEL-DECLARATIONS*</code></a>.</p>

<p>Finally, a dispatcher function with <code>NAME</code> is defined which determines
the ctype of the <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects passed for <code>:MAT</code> typed parameters. It's
an error if they are not of the same type. Scalars declared
<code>SINGLE-FLOAT</code> are coerced to that type and the appropriate kernel is
called.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-2ADEFAULT-LISP-KERNEL-DECLARATIONS-2A-20VARIABLE-29'></a></p>

<ul>
<li><p>[variable] <strong>*DEFAULT-LISP-KERNEL-DECLARATIONS*</strong> <em>((OPTIMIZE SPEED (SB-C::INSERT-ARRAY-BOUNDS-CHECKS 0)))</em></p>

<p>These declarations are added automatically to kernel functions.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3ADEFINE-CUDA-KERNEL-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p>[macro] <strong>DEFINE-CUDA-KERNEL</strong> <em>(NAME &amp;KEY (CTYPES '(:FLOAT :DOUBLE))) (RETURN-TYPE PARAMS) &amp;BODY BODY</em></p>

<p>This is an extended <code>CL-CUDA:DEFKERNEL</code> macro. It knows how to deal
with <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects and can define the same function for multiple
<code>CTYPES</code>. Example:</p>

<pre><code>(define-cuda-kernel (cuda-.+!)
    (void ((alpha float) (x :mat :input) (n int)))
  (let ((stride (* block-dim-x grid-dim-x)))
    (do ((i (+ (* block-dim-x block-idx-x) thread-idx-x)
            (+ i stride)))
        ((&gt;= i n))
      (set (aref x i) (+ (aref x i) alpha)))))
</code></pre>

<p>The signature looks pretty much like in <code>CL-CUDA:DEFKERNEL</code>, but
parameters can take the form of <code>(&lt;NAME&gt; :MAT &lt;DIRECTION&gt;)</code> too, in
which case the appropriate <code>CL-CUDA.DRIVER-API:CU-DEVICE-PTR</code> is
passed to the kernel. <code>&lt;DIRECTION&gt;</code> is passed on to the <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET MGL-PAX:MACRO)"><code>WITH-FACET</code></a>
that's used to acquire the cuda array.</p>

<p>Both the signature and the body are written as if for single floats,
but one function is defined for each ctype in <code>CTYPES</code> by transforming
types, constants and code by substituting them with their ctype
equivalents. Currently this only means that one needs to write only
one kernel for <code>FLOAT</code> and <code>DOUBLE</code>.</p>

<p>Finally, a dispatcher function with <code>NAME</code> is defined which determines
the ctype of the <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects passed for <code>:MAT</code> typed parameters. It's
an error if they are not of the same type. Scalars declared <code>FLOAT</code>
are coerced to that type and the appropriate kernel is called.</p></li>
</ul>

<p><a name='x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29'></a></p>

<h2><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSION-API-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-EXTENSION-API MGL-PAX:SECTION)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-MANUAL MGL-PAX:SECTION)">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29" title="(MGL-MAT:@MAT-DEBUGGING MGL-PAX:SECTION)">&#8634;</a></span>18 Debugging</h2>

<p>The largest class of bugs has to do with synchronization of facets
being broken. This is almost always caused by an operation that
mispecifies the <a href="cube-manual.html#x-28MGL-CUBE-3ADIRECTION-20TYPE-29" title="(MGL-CUBE:DIRECTION TYPE)"><code>DIRECTION</code></a> argument of <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET MGL-PAX:MACRO)"><code>WITH-FACET</code></a>. For example, the
matrix argument of <a href="#x-28MGL-MAT-3ASCAL-21-20FUNCTION-29" title="(MGL-MAT:SCAL! FUNCTION)"><code>SCAL!</code></a> should be accessed with direciton <code>:IO</code>. But
if it's <code>:INPUT</code> instead, then subsequent access to the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet
will not see the changes made by <a href="#x-28MGL-MAT-3AAXPY-21-20FUNCTION-29" title="(MGL-MAT:AXPY! FUNCTION)"><code>AXPY!</code></a>, and if it's <code>:OUTPUT</code>, then
any changes made to the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet since the last update of the
<a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facet will not be copied and from the wrong input <a href="#x-28MGL-MAT-3ASCAL-21-20FUNCTION-29" title="(MGL-MAT:SCAL! FUNCTION)"><code>SCAL!</code></a>
will compute the wrong result.</p>

<p>Another thing that tends to come up is figuring out where memory is
used.</p>

<p><a name='x-28MGL-MAT-3AWITH-MAT-COUNTERS-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p>[macro] <strong>WITH-MAT-COUNTERS</strong> <em>(&amp;KEY COUNT N-BYTES) &amp;BODY BODY</em></p>

<p>Count all <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> allocations and also the number of bytes they may
require. <em>May require</em> here really means an upper bound,
because <code>(MAKE-MAT (EXPT 2 60))</code> doesn't actually uses memory until
one of its facets is accessed (don't simply evaluate it though,
printing the result will access the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet if <a href="#x-28MGL-MAT-3A-2APRINT-MAT-2A-20VARIABLE-29" title="(MGL-MAT:*PRINT-MAT* VARIABLE)"><code>*PRINT-MAT*</code></a>).
Also, while facets today all require the same number of bytes, this
may change in the future. This is a debugging tool, don't use it in
production.</p>

<pre><code>(with-mat-counters (:count count :n-bytes n-bytes)
  (assert (= count 0))
  (assert (= n-bytes 0))
  (make-mat '(2 3) :ctype :double)
  (assert (= count 1))
  (assert (= n-bytes (* 2 3 8)))
  (with-mat-counters (:n-bytes n-bytes-1 :count count-1)
    (make-mat '7 :ctype :float)
    (assert (= count-1 1))
    (assert (= n-bytes-1 (* 7 4))))
  (assert (= n-bytes (+ (* 2 3 8) (* 7 4))))
  (assert (= count 2)))
</code></pre></li>
</ul>
<hr/><h6>[generated by
          <a href="https://github.com/melisgl/mgl-pax">MGL-PAX</a>]
          </h6>
          </body>
</html>
